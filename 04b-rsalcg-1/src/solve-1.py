from functools import reduce
from operator import mul
from Crypto.Util.number import isPrime as is_prime

class LCG:
    def __init__(self, bits, a=None, c=None, seed=None):
        self.seed = seed
        if self.seed is None: self.seed = secrets.randbits(bits) | 1
        self.a = a
        if self.a is None: self.a = secrets.randbits(bits) | 1
        self.c = c
        if self.c is None: self.c = secrets.randbits(bits)
        self.bits = bits
        self.m = 2**bits

    def next(self):
        self.seed = (self.seed * self.a + self.c) % self.m
        return self.seed

    def __repr__(self):
        return f'LCG(bits={self.bits}, a={self.a}, c={self.c})'

def get_prime(lcg, bits):
    while True:
        p = 0
        for i in range(bits//lcg.bits):
            p <<= lcg.bits
            p |= lcg.next()
        
        if p.bit_length() != bits: continue
        if not is_prime(p): continue

        return p

# ===

# lcg = LCG(bits=256, a=102197201962123846389438942955101245465045811321520032783251514372432272871077, c=0)
_a = 102197201962123846389438942955101245465045811321520032783251514372432272871077
_c = 0

n = 712650313276602240132329097304430048400352751513310575526412992129597422070848111072491134888258819603174150809317988369755331029009864211216547294646211646094933573124257136163629116984386416188859789467395164897001085191528084740453428500956450177548977865861466055171717564208692444769495508512419622780024874941844495178742341131675818700155796280310646897103229083027529919187454771613414875490462993045875936234591157744167214046734190302287427367403568860249349359776931200150301621481939428066984857258770478004853926288162003818241246878159630318266155498887714140614580751646422502723648142074111613225912644502226694307736726087673647398291980857229829977354067820423709011783907277562489549103977052076140881547728240425069463175586173317054911517453708001448687312406872942899280723472709421452062317503252258181984837591194705354256671714708896675155493168030996749797654707148117051477506855802867089687545890519363621855230477269747205380531049996041867129632051572747028441506474146062043427303954298727328531350438208765938027973006421501568307421856483699068172998763428694958905673708416275143602068221058898394079378423785058886143156065469790907727616640696078658243794470631540358286862899496224884600294835441
e = 65537
c = 445308155915029567991204642441037106636274278969323594266962964897048528466773947276913391974222302661172087064465526779062356615268434642959161607080766074334140739062421641878296527210809334178619685030176261525389226557543594953035919061416292966585184462770190073132725325830890587610808224156896611989260754435566640011008330800266408350415234832430226789140062590779004940578475055195767146347394381212157930691103929079825296986828415158506003438261121628407171546274414046568037336522095223978532053246031668840069046046390952201058199981492454288495640857942797704964843287034359460079316661425483842570190113998195387780579545809621808801626313837113473885818945052873823360056317079785841069224993435527933283918571286444280017102781865312454024328849395335083566145607543834607504822081522250923714391873652357185101163374950977150829214936039230387625706376713934778873385375582488086205462961139042991664546797362021066081938999660281537596860879414252495949608351649066648594254272314188241185715920283526637402373027396529855631498571685297193020517033784357794223831020791070397249992230576960345185544552280142788704673413055403847038488791910041421887897364099871208624646292906015164161354890370666964030412257423

# ==========

# solve for x^4 = u (mod 2^256)
def solve_quartic(u):
    roots = [(0, 0)]
    while len(roots):
        x0, k = roots.pop(0)
        if k == 256: yield x0
        else:
            for i in range(2):
                x1 = (i<<k) + x0
                if pow(x1, 4, 2<<k) != u % (2<<k): continue
                roots.append((x1, k+1))

def recover_seed():
    # x^4 = n * a^-k
    sum_kis = 0

    x0s = list(solve_quartic(n))
    d = list(solve_quartic(pow(_a, -4, 2**256)))[0]

    for x0 in x0s: assert pow(x0, 4, 2**256) == n % 2**256

    while True:
        for x0 in x0s:
            p = 0
            x1 = x0
            for i in range(4):
                x1 = int(_a*x1 % 2**256)

                p <<= 256
                p |= x1

            if n % p != 0: continue
            # Although we found a factor, it might not be the first prime...
            lcg = LCG(bits=256, a=_a, c=_c, seed=x0)
            ps = [get_prime(lcg, bits=1024) for _ in range(4)]
            if reduce(mul, ps) != n: continue

            return x0
        
        x0s = [x0*d % 2**256 for x0 in x0s]
        sum_kis += 4


def main():
    x0 = recover_seed()
    lcg = LCG(bits=256, a=_a, c=_c, seed=x0)

    ps = [get_prime(lcg, bits=1024) for _ in range(4)]
    phis = [p-1 for p in ps]
    phi = reduce(mul, phis)
    e = 65537
    d = int(pow(e, -1, phi))

    m = pow(c, d, n)
    flag = int(m).to_bytes((int(m).bit_length()+7)//8, 'big')
    print(f'{flag = }')

if __name__ == '__main__':
    main()
