import time
from rich.progress import track
import itertools
from functools import reduce
from operator import mul
from Crypto.Util.number import isPrime as is_prime
from Crypto.Util.number import long_to_bytes

# lcg = LCG(bits=256, a=14766004292360945258404852367497617471774948936126805425073927394403062559771, c=101392444572529008969348961056906071660419768871029068095780498478077435335658)
_a = 14766004292360945258404852367497617471774948936126805425073927394403062559771
_c = 101392444572529008969348961056906071660419768871029068095780498478077435335658

n = 310104949044058363811425892282439667555795850923698164575500719920877363952490328278993741848588550303907803963138208625777769116407165079299045658359072735954939955634899149028890186203432587177185672614983999894171325785452784795686085757918290966774324125319406224747711723917236527562556229579589022628862590296281590323788478820477333016394079937231878378358046269624402362566235154381484471820688582120004595351405438024178098190005187895688879764539037795309008703147966413618274215850034115978270168263624156747737483336047033398686990065931568589053366201551840168657333564635190953575770912434947264202860664609208924668470174089395139643640441218757659152083626042918967413234744394606549606305861281752161107561439760204185976944782327736965087510398008449771008025699947582049442588729371212204993669594933838721600502189158688622194652824336960901728311819450912079584032482610919375366829986623070788751982011540521220055895553821778224253746970625666841786339189340344498152279172317609743104777470108401770109956350920020610131660906732383196598286142112787914912796448301345111823730145040316068582039211121377301361760688564938322941885358577303167411970251703604232966219027983536858119778300500933101751641899457
e = 65537
c = 103062216319994633883021726707255505833894115982244229797744500400724941059411346264133479322957473182662752018633592486294774530211270693527482730004815628242002327808204776228223444383519632042858531074466552102288702530352869324049976713089889252600765238196110451324303956172732401402047005544975223308718486936799382134071405038584109821524691964342940757473561547043393942877521141027936710682878315017107714350048208655766169663561363722598270709129397838087810818396682268983758680728353233325680608113581239966748966828100455121487936700949018790286804701500925964419202040562160087415752569883786048654250026952720505649274955681447219364518875892085854376617187428517680579374255991868541726338897567149638047885985817814723274557132684796698662679779677729590702208805883768828626340945484760552452520907126473183457061321026569739763527385628295340908066618403473190885048961117252304808518351740671498261396384433967551138018727839531240932197016466713851341150888734655103395641340466366445201973820121462512449662479632578237405866465926851495594436176622348441495580476338358402531879195673909374090632193981789951544889982768669254824649367936539308980191669227919352771464458152027996758074065744620552247585183945

# ===

class LCG:
    def __init__(self, bits, a=None, c=None, seed=None):
        self.seed = seed
        if self.seed is None: self.seed = secrets.randbits(bits) | 1
        self.a = a
        if self.a is None: self.a = secrets.randbits(bits) | 1
        self.c = c
        if self.c is None: self.c = secrets.randbits(bits)
        self.bits = bits
        self.m = 2**bits

    def next(self):
        self.seed = (self.seed * self.a + self.c) % self.m
        return self.seed

    def __repr__(self):
        return f'LCG(bits={self.bits}, a={self.a}, c={self.c})'


def get_prime(lcg, bits):
    while True:
        p = 0
        for i in range(bits//lcg.bits):
            p <<= lcg.bits
            p |= lcg.next()
        
        if p.bit_length() != bits: continue
        if not is_prime(p): continue
        return p

# Find x such that a^x = b (mod 2^256)
def dlog(a, b):
    candidates = [(0, 0)]
    while len(candidates) > 0:
        u, v = candidates.pop(0)
        if v == 256:
            assert pow(a, u, 2**256) == b % 2**256
            return u
        else:
            for i in [0, 1<<v]:
                if pow(a, u+i, 2<<v) != b % (2<<v): continue
                candidates.append((u+i, v+1))

assert 1337 == dlog(5, pow(5, 1337, 2**256))

def s(n):
    if n == 0: return 0
    if n == 1: return 1
    if n % 2 == 0: return (1 + pow(_a, n//2, 2**256)) * s(n//2) % 2**256
    return (1 + _a*s(n-1)) % 2**256

for i in range(50):
    assert sum(pow(_a, j, 2**256) for j in range(i)) % 2**256 == s(i)

assert pow(5, 2**125, 2**128) != 1
assert pow(5, 2**126, 2**128) == 1

y, xi = 1, 1

lgxs = [0]
lgn = dlog(5, n)

done = False
two_sums = {}
while True:
    if y % 50 == 0: print(f'Trying {y = }')
    for _ in range(4): xi = (_a * xi + _c) % 2**128
    lgx = dlog(5, xi)
    lgxs.append(lgx)

    # Add to our two-sums
    for x in range(y+1):
        two_sums[(lgxs[x] + lgxs[y]) % 2**126] = (x, y)

    lgt = (lgn - lgxs[y]) % 2**126
    for x, lgx in enumerate(lgxs):
        lgy = (lgt - lgx) % 2**126
        if two_sums.get(lgy) is None: continue
        v, w = two_sums[lgy]
        done = True
        break
    if done: break

    y += 1

# ========

# mod 2^128
ids = sorted([v, w, x, y])
print(f'{ids = }')

ps = [pow(5, lgxs[id], 2**128) for id in ids] # ps mod 2^128

assert reduce(mul, ps) % 2**128 == n % 2**128

_as = [pow(_a, 4*id, 2**256) for id in ids]
_cs = [s(4*id)*_c % 2**256   for id in ids]

# recover the initial state
def solve_quartic(_as, _cs):
    a1, a2, a3, a4 = _as
    c1, c2, c3, c4 = _cs

    roots = [(0, 0)]
    while len(roots):
        x0, k = roots.pop(0)
        if k == 256:
            assert (a1*x0+c1)*(a2*x0+c2)*(a3*x0+c3)*(a4*x0+c4) % 2**256 == n % 2**256
            yield x0
        else:
            for i in range(2):
                x1 = (i<<k) + x0
                if (a1*x1+c1)*(a2*x1+c2)*(a3*x1+c3)*(a4*x1+c4) % (2<<k) != n % (2<<k): continue
                roots.append((x1, k+1))

for seed in solve_quartic(_as, _cs):
    print(f'{hex(seed) = }')
    lcg = LCG(bits=256, a=_a, c=_c, seed=seed)
    ps = [get_prime(lcg, bits=1024) for _ in range(4)]
    print(f'{ps = }')
    if ps[0]*ps[1]*ps[2]*ps[3] != n: continue
    break
else:
    assert False, 'skill issue'

# ===

n = ps[0] * ps[1] * ps[2] * ps[3]
phi = (ps[0]-1) * (ps[1]-1) * (ps[2]-1) * (ps[3]-1)
e = 0x10001
d = pow(e, -1, phi)

m = pow(c, d, n)

flag = long_to_bytes(m)
print(f'{flag = }')
